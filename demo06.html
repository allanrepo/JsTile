<!DOCTYPE HTML>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Testing Map Class Demo</title>
    <script type="text/javascript" src = "./scene.js"></script>
    <script type="text/javascript" src = "./tile.js"></script>
    <script type="text/javascript" src = "./ui.js"></script>
    <script type="text/javascript" src = "./sprite.js"></script>
    <script type="text/javascript" src = "./engine.js"></script>
	<script type="text/javascript">
		var scene;
        var ui, perf, ctrlframe, mapctrlframe;
        var tmap = [];
        var loadmapbutton;
        var mapSize = 0;
        var map;
        var p = { x: 50, y: 50, r: 87, c:99 };

		/* ---------------------------------------------------------------------------------------------
		called on <body> to initiate js scenelication
		--------------------------------------------------------------------------------------------- */
		function init()
		{		
			// create scene object
			scene = new Scene("sim_canvas");	
			scene.setSize(1024, 768);
			scene.setBackgroundColor("#ffffff");
			scene.setPos(5, 5);			
			scene.autoFitDocument(true);

            // create ui
            ui = new engine.ui(scene, "root");	
            ui.addEventListener("mousedrag", onmousedrag);
            ui.addEventListener("draw", onrootdraw);
            ctrlframe = new engine.frame(ui, "ctrl", 5, 5, 320, 480, true, true);   
            ctrlframe.hide(true);

            mapctrlframe = new engine.frame(ui, "mapctrlframe", 5, 5, 300, 300, true, true);   
            loadmapbutton = new engine.button(mapctrlframe, "loadmapbutton", 10, 10, 120, 40, "Load Map" );
            loadmapbutton.addEventListener("mouseup", onloadmap);
            loadmapbutton.addEventListener("draw", drawloadmap);
            loadmapbutton.map = [];
            
            new engine.switch(ctrlframe, "switch", 10, 10, 20, "Blue");         
            new engine.switch(ctrlframe, "switch", 10, 50, 24, "Red");         
            new engine.switch(ctrlframe, "switch", 10, 90, 16, "Green");        
            new engine.button(ctrlframe, "button", 10, 200, 200, 60, "This Text Is Clipped Because It's Too Long" );
            new engine.slider(ctrlframe, "slider", false, 10, 280, 200, 24, 50, 100);
            new engine.slider(ctrlframe, "slider", true, 10, 320, 100, 32, 5, 10);

            perf = new engine.frame(ui, "ctrl", 50, 50, 480, 320, true, true);   
            perf.addEventListener("draw", drawStuff);
            //perf.hide(true);

            map = new Map(72, 144, 24);
			map.addTile("../png/tiles/tile_1x1_tw144_d72_b24.png", 1, 1);
            map.addTile("../png/tiles/tile_1x1_grass.png", 1, 1);
          
            // add the application loop event running at max interval
            scene.addEvent(run, 1);

            //processLargeArray(map);
            //console.log("length: " + map.length);

					
			// run the scene
            scene.start();	                       
        }

        function onrootdraw(e)
        {
            if (map.col == p.c && map.row == p.r) map.draw(scene, p.x, p.y);

        }

        function onmousedrag(e)
        {
            p.x += e.dx; 
            p.y += e.dy;


        }

        function onloadmap(e)
        {            
            //e.elem.map = [];
            //generate(e.elem.map, 100000, 1, 3415, 2875);
            map.create(p.r, p.c, 50, 10);
        }

        function drawloadmap(e)
        {
            //scene.drawText(mapSize, e.x + 10, e.y + 60, 100, 24, 24, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'top');
            //scene.drawText(e.elem.map.length + ", " + (e.elem.map.length? e.elem.map[e.elem.map.length - 1].length : 0), 
            //               e.x + 10, e.y + 90, 100, 24, 24, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'top');
            scene.drawText(map.row + ", " + map.col, e.x + 10, e.y + 90, 100, 24, 24, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'top');
        }


        function generate(map, chunk, sleep, row, col)
        {            
            function loadPerChunk()
            {
                var n = chunk;
                while(n)
                {
                    // if we reach expected number of rows, don't add anymore
                    if (map.length == row)
                    {                  
                        // if we're here, we are on the last row. if this row's full, let's bail
                        if (map[map.length - 1].length == col)
                        {
                            // we done now
                            console.log("bailing.. " + map.length);
                            break; 
                        }
                        // if we reach this point, this last row is not yet full. let's add more 
                        map[map.length - 1].push("1");
                    }
                    // we still have room to add more rows before reaching expected 
                    else
                    {
                        // let's handle the first iteration where map does not have any rows yet. just add one
                        if (!map.length)
                        {
                            map.push([]);
                        }
                        // if this row is full already, add new row
                        else if (map[map.length - 1].length == col)
                        {
                            map.push([]);
                        }
                        // this row is not full yet OR we're on new empty row. add data
                        map[map.length - 1].push("1");
                    }

                    // this variable is to determine if we already performed in chunk size
                    n--;
                }

                //console.log(">> " + map.length + ", " + map[map.length - 1].length);

                if(map.length)
                {
                    if( (map.length? (map[map.length - 1].length < col): true) || map.length < row)
                    {
                        setTimeout(loadPerChunk, sleep);
                    }
                    else
                    {
                        console.log(">> " + map.length + ", " + map[map.length - 1].length);
                    }
                }
            };
            loadPerChunk();
        }

        function processLargeArray(arr) 
        {
            // set this to whatever number of items you can process at once
            var chunk = 1000;
            var index = 0;
            function doChunk() 
            {
                var cnt = chunk;
                while (cnt-- && index < 1000000) 
                {
                    // process array[index] here
                    arr.push("hello world");
                    ++index;
                }
                if (index < 1000000) 
                {
                    // set Timeout for async iteration
                    setTimeout(doChunk, 100);
                }
            }    
            doChunk();    
        }
        
        function drawStuff(e)
        {
            scene.shadowBlur = 0;
            //scene.drawRect(e.x + 15, e.y + 15, 400, 64, 'rgba(255, 255, 255, 1)', 'rgba(255, 255, 255, 1)');
            //scene.drawText("Hello World.", e.x + 15, e.y + 15, 400, 64, 32, 'verdana', 'rgba(128, 128, 255, 1)', 'center', 'center', true);
            scene.drawText("Frame Rate", e.x + 5, e.y + 5, 0, 24, 24, 'impact', 'rgba(255, 255, 255, 1)');
            scene.drawText("fps", e.x + 120, e.y + 5, 0, 24, 16, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'bottom');
            scene.drawText(e.elem.fps.toFixed(1), e.x + 5, e.y + 36, 0, 48, 48, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'bottom');

            scene.drawText("Screen Size", e.x + 5, e.y + 110, 0, 24, 24, 'impact', 'rgba(255, 255, 255, 1)');
            scene.drawText("pixels", e.x + 125, e.y + 110, 0, 24, 16, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'bottom');
            scene.drawText(scene.width + "x" + scene.height, e.x + 5, e.y + 124, 0, 48, 32, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'bottom');

            //scene.drawText(map.length, e.x + 5, e.y + 160, 0, 48, 32, 'verdana', 'rgba(192, 192, 192, 1)', 'left', 'bottom');
        }

		/* ---------------------------------------------------------------------------------------------
		application loop 
		--------------------------------------------------------------------------------------------- */
 		function run(info)    
		{         
            perf.fps = info.fps;   
			scene.clear();	
            ui.draw();		                        
		}		
		
	</script>
</head>
<body onload = "init()" style="margin: 0">
    <canvas style="margin-left: left; margin-right: right; display: block; margin: 0;" id = "sim_canvas"  >
        Your browser does not support the HTML5 canvas tag.
    </canvas>
 </body>
</html>